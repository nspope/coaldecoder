#include <RcppArmadillo.h> 
#include <map>

// converted almost verbatim from ...
// reverse diff is my own

using namespace arma;

std::map<int, double> _theta = {
  {1, 2.29e-16},
  {2, 2.58e-8},
  {3, 1.39e-5},
  {4, 3.40e-4},
  {5, 2.40e-3},
  {6, 9.07e-3},
  {7, 2.38e-2},
  {8, 5.00e-2},
  {9, 8.96e-2},
  {10, 1.44e-1},
  {11, 2.14e-1},
  {12, 3.00e-1},
  {13, 4.00e-1},
  {14, 5.14e-1},
  {15, 6.41e-1},
  {16, 7.81e-1},
  {17, 9.31e-1},
  {18, 1.09},
  {19, 1.26},
  {20, 1.44},
  {21, 1.62},
  {22, 1.82},
  {23, 2.01},
  {24, 2.22},
  {25, 2.43},
  {26, 2.64},
  {27, 2.86},
  {28, 3.08},
  {29, 3.31},
  {30, 3.54},
  {35, 4.7},
  {40, 6.0},
  {45, 7.2},
  {50, 8.5},
  {55, 9.9}
};

double _onenormest_matrix_power(const mat& A, int p, int t=2)
{
  //t is evidently unused
  return norm(powmat(A, p), 1);
}

double _exact_1_norm (const mat& A)
{
  return norm(A, 1);
}

double _trace (const mat& A)
{
  return trace(A);
}

double _exact_inf_norm (const mat& A)
{
  return norm(A, "inf");
}

struct _operator_norm_info
{
  const mat& _A;
  double _A_1_norm, _scale;
  int _ell;
  std::map<int, double> _d;

  _operator_norm_info (const mat& A, double A_1_norm, int ell, double scale = 1.)
    : _A (A), _A_1_norm (A_1_norm), _ell (ell), _scale (scale)
  {}

  void set_scale (double scale)
  {
    _scale = scale;
  }

  double onenorm (void)
  {
    return _scale * _A_1_norm;
  }

  double d (int p)
  {
    if (_d.find(p) == _d.end())
    {
      double est = _onenormest_matrix_power(_A, p, _ell);
      _d[p] = std::pow(est, 1.0 / double(p));
    }
    return _scale * _d[p];
  }

  double alpha (int p)
  {
    return std::max(d(p), d(p+1));
  }
};

long int _compute_cost_div_m (int m, int p, _operator_norm_info& norm_info)
{
  return (long int)(std::ceil(norm_info.alpha(p) / _theta[m]));
}

int _compute_p_max (int m_max)
{
  double sqrt_m_max = std::sqrt(m_max);
  int p_low = int(std::floor(sqrt_m_max));
  int p_high = int(std::ceil(sqrt_m_max + 1));
  int p_max = -1; 
  for (int p=p_low; p<p_high+1; ++p)
  {
    if (p*(p-1) <= m_max + 1)
    {
      if (p > p_max)
      {
        p_max = p;
      }
    }
  }
  return p_max;
}

bool _condition_3_13 (double A_1_norm, int n0, int m_max, int ell)
{
  int p_max = _compute_p_max(m_max);
  int a = 2 * ell * p_max * (p_max + 3);
  double b = _theta[m_max] / double(n0 * m_max);
  return A_1_norm <= a * b;
}

ivec _fragment_3_1 (_operator_norm_info& norm_info, int n0, double tol, int ell)
{
  if (ell < 1) Rcpp::stop("ERROR ell < 1");
  int m_max  = 55;
  long int best_m = -1;
  long int best_s = -1;
  if (_condition_3_13(norm_info.onenorm(), n0, m_max, ell))
  {
    for (const auto& _theta_ptr : _theta)
    {
      long int m = _theta_ptr.first;
      double theta = _theta_ptr.second;
      long int s = std::ceil(norm_info.onenorm() / theta);
      if (best_m == -1 || m*s < best_m*best_s)
      {
        best_m = m;
        best_s = s;
      }
    }
  } else {
    for (int p=2; p<_compute_p_max(m_max)+1; ++p)
    {
      for (int m=p*(p-1)-1; m<m_max+1; ++m)
      {
        if (_theta.find(m) != _theta.end())
        {
          long int s = _compute_cost_div_m(m, p, norm_info);
          if (best_m == -1 || m*s < best_m*best_s)
          {
            best_m = m;
            best_s = s;
          }
        }
      }
    }
    best_s = std::max(best_s, (long int)(1));
  }
  return ivec({int(best_m), int(best_s)});
}

mat _expm_multiply_simple_core (const mat& A, mat B, double t, double mu, int m_star, int s, double tol, ivec& m_break, std::vector<mat>& B_end)
{
  m_break = zeros<ivec>(s);
  B_end.resize(s+1);
  mat F = B; 
  mat B_old;
  double eta = std::exp(t * mu / double(s)); 
  for(int i=0; i<s; ++i)
  {
    B = F; 
    double c1 = _exact_inf_norm(B);
    m_break[i] = m_star-1;
    for(int j=0; j<m_star; ++j)
    {
      double coeff = t / double(s*(j+1));
      B_old = B;
      B = coeff * A * B;
      double c2 = _exact_inf_norm(B);
      //if (abs(B).max() <= 1e-8)
      //// NATE: added b/c of revdif numerical issues
      //// if B gets too close to 0, we can't reconstruct it later
      //// so we make the approximation less accurate to
      //// make the gradient of the approximation more accurate
      //{
      //  m_break[i] = j-1;
      //  B = B_old;
      //  break;
      //}
      F += B; 
      if (c1 + c2 <= tol * _exact_inf_norm(F)) 
      {
        m_break[i] = j;
        break;
      }
      c1 = c2;
    }
    F *= eta; 
    B_end[i] = B;
  }
  B_end[s] = F;
  return F; 
}

mat _expm_multiply_simple (mat A, mat B, const double t, int& s, ivec& m_break, std::vector<mat>& B_end)
{
  mat ident = eye(size(A));
  int n = A.n_rows;
  int n0 = B.n_cols;
  double tol = std::pow(2, -53);
  double mu = _trace(A) / double(n);
  A -= mu * ident; 
  double A_1_norm = _exact_1_norm(A);
  int m_star;
  if (t*A_1_norm == 0.)
  {
    m_star = 0;
    s = 1;
  } else {
    int ell = 2;
    _operator_norm_info norm_info(t*A, t*A_1_norm, ell);
    ivec frag = _fragment_3_1(norm_info, n0, tol, ell);
    m_star = frag[0];
    s = frag[1];
  }
  return _expm_multiply_simple_core(A, B, t, mu, m_star, s, tol, m_break, B_end);
}

void _expm_multiply_simple_core_revdif (const mat& dX, mat& dA, mat& dB, double& dmu, const mat& A, const std::vector<mat>& B, const double mu, const int s, const double t, const ivec& m_break)
{
      std::cout.precision(16); std::cout.setf(std::ios::fixed);//DEBUG
  std::map<int,std::map<int,mat>> Frev, Brev;
  double eta = std::exp(t * mu / double(s)); 
  double deta = 0;
  mat Ainv = A.i(); //TODO factorize instead
  mat F = B[s];
  mat dF = dX;
  dA = zeros(size(A));
  for(int i=s-1; i>=0; --i)
  {
    F /= eta;
    deta += dot(dF, F);
    dF = dF * eta;
    dB = zeros(size(dX));
    mat Bij = B[i];
    for(int j=m_break[i]; j>=0; --j)
    {
      long double coeff = t / (long double)(s*(j+1));
      dB += dF;
      F = F - Bij;
      Bij = Ainv * Bij / coeff; //solve(A, Bij)/coeff;
      dA += dB * trans(Bij) * coeff;
      dB = coeff * A.t() * dB;
    }
    dF += dB;
  }
  dmu = deta * eta * t/double(s);
  dB = dF;

  //forward:
  //F[0,0] = in;
  //for(int i=0; i<s; ++i)
  //{
  //  B[i,0] = F[i,0];
  //  for(int j=0; j<=m_break[i]; ++j)
  //  {
  //    B[i,j+1] = coeff[i,j] * A * B[i,j]; 
  //    F[i,j+1] = F[i,j] + B[i,j+1]; 
  //  }
  //  F[i+1,0] = F[i,m_break[i]+1] * eta; 
  //}
  //out:F[s,0]

  //backward:
  // dF[s,0] = in;
  // for(int i=s-1; i>=0; --i)
  // {
  //   deta[i]  = dot(dF[i+1,0], F[i,m_break[i]+1]);
  //   dF[i,m_break[i]+1] = dF[i+1,0] * eta;
  //   dB[i,m_break[i]+1] = zeros;
  //   for(int j=m_break[i]; j>=0; --j)
  //   {
  //     dF[i,j] = dF[i,j+1];
  //     dB[i,j+1] += dF[i,j+1];
  //     dA += dB[i,j+1] * trans(B[i,j]) * coeff[i,j];
  //     dB[i,j] = coeff[i,j] * A.trans() * dB[i,j+1];
  //   }
  //   dF[i,0] += dB[i,0];
  // }
  // out:dF[0,0]
}

arma::mat _expm_multiply_simple_revdif(const mat& dX, mat& dA, mat& dB, mat A, const std::vector<mat>& B_end, const double t, const int s, const ivec& m_break)
{
  int n = A.n_rows;
  double dmu = 0;
  double mu = _trace(A)/double(n); 
  mat ident = eye(size(A));
  A -= mu * ident;
  _expm_multiply_simple_core_revdif(dX, dA, dB, dmu, A, B_end, mu, s, t, m_break);
  //dmu -= accu(dA.diag());
  //dA.diag() -= dmu/double(n);
}

// [[Rcpp::export]]
Rcpp::List my_expm (arma::mat A, arma::mat B, double t)
{
  ivec m_break;
  std::vector<mat> B_end;
  int s;
  mat out = _expm_multiply_simple (A, B, t, s, m_break, B_end);
  mat dA; mat dB; mat dX = B;
  _expm_multiply_simple_revdif (dX, dA, dB, A, B_end, t, s, m_break);
  return Rcpp::List::create(
      Rcpp::_["dA"] = dA,
      Rcpp::_["dB"] = dB,
      Rcpp::_["X"] = out,
      Rcpp::_["s"] = s,
      Rcpp::_["m_break"] = m_break
      );
}

